export { coerce, computedHandlers, converter, fast, pmwh }
/* deno-fmt-ignore */ import {must, fooga, mconfig, unreachable, notify, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
import { handlers } from "./handlers.js"
import { getTailwindColor } from "/home/kdog3682/2024-javascript/csx/getColor.js"
import * as assets from "./assets.js"

const configItems = [
    { key: "padding-left", alias: "pl", handler: "pmwh" },
    { key: "padding-right", alias: "pr", handler: "pmwh" },
    { key: "padding-top", alias: "pt", handler: "pmwh" },
    { key: "padding-bottom", alias: "pb", handler: "pmwh" },
    { key: "margin-top", alias: "mt", handler: "pmwh" },
    { key: "margin-right", alias: "mr", handler: "pmwh" },
    { key: "margin-bottom", alias: "mb", handler: "pmwh" },
    { key: "margin-left", alias: "ml", handler: "pmwh" },
    { key: "width", alias: "w", handler: "pmwh" },
    { key: "height", alias: "h", handler: "pmwh" },
    { key: "top", alias: "t", handler: "pmwh" },
    { key: "right", alias: "r", handler: "pmwh" },
    { key: "bottom", alias: "b", handler: "pmwh" },
    { key: "left", alias: "l", handler: "pmwh" },
    { key: "min-width", alias: "minw", handler: "pmwh" },
    {
        key: "border-radius",
        alias: "radius br",
        handler: "pmwh",
    },
    { key: "max-width", alias: "maxw", handler: "pmwh" },
    { key: "min-height", alias: "minh", handler: "pmwh" },
    { key: "max-height", alias: "maxh", handler: "pmwh" },
    { key: "border-width", alias: "bw", handler: "pmwh" },
    { key: "gap", alias: "gap", handler: "pmwh" },
    { key: "row-gap", alias: "rgap", handler: "pmwh" },
    { key: "column-gap", alias: "cgap", handler: "pmwh" },
    { key: "font-size", alias: "fs size", handler: "pmwh" },

    {
        key: "background-color",
        alias: "bg fill",
        handler: "color",
    },
    { key: "border-color", alias: "bc", handler: "color" },
    { key: "outline-color", alias: "oc", handler: "color" },
    { key: "color", alias: "fci c fc", handler: "color" },
    { key: "margin", alias: "m outset", handler: "margin" },
    { key: "padding", alias: "p inset", handler: "padding" },
    { key: "z-index", alias: "zi", handler: "identity" },
    { key: "line-height", alias: "lh", handler: "identity" },
    { key: "opacity", alias: "o", handler: "identity" },
    {
        key: "font-weight",
        alias: "fw weight",
        handler: "identity",
    },
    {
        key: "font-family",
        alias: "ff font",
        handler: "fontFamily",
    },
    { alias: "grid", handler: "grid" },
    { alias: "cm", handler: "colorMatch" },
    { alias: "sandwich sand", handler: "sandwich" },
    { alias: "flex", handler: "flex" },
    { alias: "border stroke", handler: "stroke" },
    { alias: "mx", handler: "_margin", args: "x" },
    { alias: "my", handler: "_margin", args: "y" },
    { alias: "px", handler: "_padding", args: "x" },
    { alias: "py", handler: "_padding", args: "y" },
]

function converter(...args) {
    const converterAB = (a, b) => {
        if (b === true) {
            if (/^[a-z]\d$/.test(a)) {
                return [["color", getTailwindColor(a)]]
            }
            return must(assets.cabmap, a)
        }
        const { handler, key } = must(computedHandlers, a)
        const value = coerce(handler(b, a), key)
        return fix(value)
    }

    const converterO = (o, mode) => {
        const values = Object.entries(o).map(([k, v]) => {
            if (!hasValue(v)) {
                return
            }
            return converterAB(k, v)
        }).filter(isDefined).flat()
        return mode == Object
            ? values.reduce(simpleReducer, {})
            : values
    }

    const converterS = (s) => {
        const r = /([\w-]+)(?: *[:=] *([\w-]+))?/g
        const items = matchall(s, r)
        const matches = items.map((item) => {
            const [a, b] = item[2] == null
                ? [item[1], true]
                : [item[1], item[2]]
            return converterAB(a, b)
        })
        return matches.flat()
    }

    switch (args.length) {
        case 1:
            if (isObject(args[0])) {
                return converterO(...args)
            } else {
                return converterS(...args)
            }
        case 2:
            if (args[1] == Object) {
                return converterO(...args)
            }
            return converterAB(...args)
        default:
            panic("only 1 or 2 args allowed")
    }
}
function coerce(value, key) {
    return isArray(value) ? value : [[key, value]]
}

const create = (acc, item) => {
    const value = {
        key: item.key,
    }

    const ignore = ["identity", "pmwh", "color"]
    assert(item.handler)
    if (ignore.includes(item.handler)) {
        value.handler = identity
    } else {
        value.handler = must(handlers, item.handler)
    }

    xsplit(item.aliases || item.alias).forEach((a) => {
        acc[a] = value
    })
    if (item.key) {
        acc[item.key] = value
    }
    return acc
}

function pmwh(s) {
    const ref = {
        "0": 0,
        "fit": "fit-content",
    }
    if (ref.hasOwnProperty(s)) {
        return ref[s]
    }
    if (isNumber(s)) {
        return s + "pt"
    }
    return s
}

function fix(value) {
    const get = (a, b) => {
        const t = assets.typeMap[a]
        switch (t) {
            case "length":
                return pmwh(b)
            case "color":
                return getTailwindColor(b, null)
            default:
                return b
        }
    }

    let direction = 0
    const directions = [
        "top",
        "right",
        "left",
        "bottom",
        "x",
        "y",
    ]
    let position = 0

    const transformer = (aa) => {
        return aa.map(([a, b]) => {
            if (a == "position") {
                position = 1
            } else if (directions.includes(a)) {
                direction = 1
            }

            const value = get(a, b)
            return [a, value]
        })
    }
    const payload = transformer(value)
    if (position == 0 && direction == 1) {
        payload.push(["relative", "position"])
    }
    return payload
}

function simpleReducer(acc, [a, b]) {
    acc[a] = b
    return acc
}
const computedHandlers = configItems.reduce(create, {})

const borderRefAliases = {
    "bl": "left",
    "b": "",
    "bt": "top",
    "br": "right",
    "bb": "bottom",
    "bx": ["left", "right"],
    "by": ["top", "bottom"],
}

function fast(s) {
    const items = split(s)
    let m
    const mapper = (item) => {
        if (assets.cabmap.hasOwnProperty(item)) {
            return assets.cabmap[item]
        }
        if (assets.roygbiv.includes(item)) {
            return [["color", item]]
        }
        if (item.startsWith("bg")) {
            return [[
                "background",
                getTailwindColor(item.slice(2)),
            ]]
        }
        if (item.startsWith("cm")) {
            return handlers.colorMatch(item.slice(2))
        }

        const borderRE =
            /^(b[xyltrb]?)(blue|green|indigo|orange|red|violet|yellow|black|gray)(\d+(?:\.\d+)?)$/

        if (m = match(item, borderRE)) {
            const [prefix, color, width] = m
            // console.log({prefix, color, width})
            const dir = borderRefAliases[prefix]
            // console.log({dir})
            return handlers._stroke({
                thickness: width,
                paint: color,
            }, dir)
        } else if (m = match(item, /^([a-z]+)(\d.*)$/i)) {
            const [a, b] = m
            if (computedHandlers.hasOwnProperty(a)) {
                const { handler, key } = computedHandlers[a]
                return coerce(handler(b, a), key)
            } else {
                if (/^[a-z]\d$/.test(a)) {
                    return [["color", getTailwindColor(a)]]
                }
            }
        }
        throw new Error(`"${item}" is invalid key`)
    }

    const payload = fix(items.map(mapper).flat())
    return dict(payload)
}
// console.log(fast('cmb3'))
